<!DOCTYPE html>
<html lang="es" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NAVALEK SPA - Proyectos de Ingeniería Eléctrica</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&display=swap" rel="stylesheet">

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.module.js"
            }
        }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0d1a3f; color: #f3f4f6; }
        #webgl-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; z-index: 0; }
        .scroll-content { position: relative; z-index: 10; color: white; padding-top: 100vh; }
        .hero-section { height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; position: relative; z-index: 5; padding: 1rem; }
        .glass-card { background: rgba(13, 26, 63, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border: 1px solid rgba(168, 126, 255, 0.1); }
        .hexagon-clip { clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%); }

        /* Estilos para el Overlay de Espaciado Interactivo */
        #spacing-overlay {
            position: absolute;
            border: 2px dashed rgba(139, 92, 246, 0.7); /* Morado */
            box-sizing: border-box;
            z-index: 1000;
            pointer-events: none; /* Ignora el ratón en el overlay principal */
            display: none; /* Oculto por defecto */
        }
        .handle {
            position: absolute;
            background-color: rgba(139, 92, 246, 1); /* Morado sólido */
            pointer-events: auto; /* Los manejadores SÍ interactúan con el ratón */
            cursor: grab;
        }
        .handle-top, .handle-bottom { width: 40px; height: 8px; left: 50%; transform: translateX(-50%); }
        .handle-left, .handle-right { width: 8px; height: 40px; top: 50%; transform: translateY(-50%); }
        .handle-top { top: -4px; }
        .handle-bottom { bottom: -4px; }
        .handle-left { left: -4px; }
        .handle-right { right: -4px; }
    </style>
</head>
<body class="antialiased">

    <canvas id="webgl-canvas"></canvas>

    <!-- Overlay para edición de espaciado -->
    <div id="spacing-overlay">
        <div class="handle handle-top" data-direction="pt"></div>
        <div class="handle handle-right" data-direction="pr"></div>
        <div class="handle handle-bottom" data-direction="pb"></div>
        <div class="handle handle-left" data-direction="pl"></div>
    </div>

    <div id="app-container">
        <!-- El contenido de la página se renderizará aquí dinámicamente -->
    </div>

    <!-- Script de Renderizado y Carga de Esquema -->
    <script type="module">
        import { pageSchema as defaultSchema } from './page-schema.js';
        import { renderPage } from './renderer.js';
        import * as THREE from 'three';

        let currentSchema;

        function initializePage() {
            // Cargar el esquema desde localStorage o usar el predeterminado
            try {
                const savedSchema = localStorage.getItem('userPageSchema');
                currentSchema = savedSchema ? JSON.parse(savedSchema) : defaultSchema;
            } catch (e) {
                console.error("Error al cargar el esquema, usando el predeterminado.", e);
                currentSchema = defaultSchema;
            }

            // Renderizar la página
            const container = document.getElementById('app-container');
            if (container) {
                renderPage(currentSchema, container);
            }
        }

        // Asegurarse de que el DOM esté completamente cargado antes de ejecutar el script
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePage);
        } else {
            initializePage();
        }

        // --- API de Actualización en Vivo (Enfoque Granular) ---
        window.liveUpdater = {
            updateStyle: (elementId, styleProp, value) => {
                const element = document.getElementById(elementId);
                if(element) {
                    element.style[styleProp] = value;
                }
            },
            updateText: (elementId, newText) => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = newText;
                }
            },
            updateAttribute: (elementId, attribute, value) => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.setAttribute(attribute, value);
                }
            },
            addElement: (containerSelector, itemHtml) => {
                const container = document.querySelector(containerSelector);
                if (container) {
                    container.insertAdjacentHTML('beforeend', itemHtml);
                }
            },
            removeElement: (elementId) => {
                const element = document.getElementById(elementId);
                // Busca el contenedor del item más cercano para eliminarlo
                if (element) {
                    const itemWrapper = element.closest('.glass-card, .hexagon-clip');
                    if (itemWrapper) itemWrapper.remove();
                }
            },
            updateAnimation: (uniformName, value) => {
                if (material && material.uniforms[uniformName]) {
                    if (uniformName.toLowerCase().includes('color')) {
                        material.uniforms[uniformName].value.set(value);
                    } else {
                        material.uniforms[uniformName].value = value;
                    }
                }
                if (uniformName === 'u_mouseFollowSpeed') {
                    settings.mouseFollowSpeed = value;
                }
            },
            updateSpacing: (elementId, spacingObject) => {
                const element = document.getElementById(elementId);
                if (!element) return;

                // Filtrar clases existentes para remover las de padding
                const preservedClasses = Array.from(element.classList).filter(c =>
                    !c.startsWith('pt-') &&
                    !c.startsWith('pb-') &&
                    !c.startsWith('pl-') &&
                    !c.startsWith('pr-')
                );

                // Crear las nuevas clases de spacing
                const spacingClasses = Object.entries(spacingObject)
                    .map(([key, value]) => `${key}-${value}`);

                // Combinar y aplicar
                element.className = [...preservedClasses, ...spacingClasses].join(' ');
            }
        };

        // --- Lógica del WebGL y Animaciones ---
        const heroSection = currentSchema.find(s => s.type === 'hero');
        const settings = heroSection ? heroSection.content : {};

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 10);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webgl-canvas'), alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const planeSize = 50;
        const planeSegments = 50;
        const geometry = new THREE.PlaneGeometry(planeSize, planeSize, planeSegments, planeSegments);

        const colorA = new THREE.Color(settings.colorA);
        const colorB = new THREE.Color(settings.colorB);
        const colorInteraction = new THREE.Color(settings.colorInteraction);

        const material = new THREE.ShaderMaterial({
            uniforms: {
                u_time: { value: 0.0 },
                u_scroll: { value: 0.0 },
                u_mouse: { value: new THREE.Vector2(0, 0) },
                u_color_a: { value: colorA },
                u_color_b: { value: colorB },
                u_color_interaction: { value: colorInteraction },
                u_mouse_wave_radius: { value: settings.mouseWaveRadius },
                u_mouse_wave_intensity: { value: settings.mouseWaveIntensity }
            },
            vertexShader: `
                uniform float u_time, u_scroll, u_mouse_wave_radius, u_mouse_wave_intensity;
                uniform vec2 u_mouse;
                varying float v_wave, v_mouse_wave;
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
                float snoise(vec2 v) {
                    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                    vec2 i  = floor(v + dot(v, C.yy) );
                    vec2 x0 = v -   i + dot(i, C.xx);
                    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                    vec4 x12 = x0.xyxy + C.xxzz;
                    x12.xy -= i1;
                    i = mod289(i);
                    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                    m = m*m; m = m*m;
                    vec3 x = 2.0 * fract(p * C.www) - 1.0;
                    vec3 h = abs(x) - 0.5;
                    vec3 ox = floor(x + 0.5);
                    vec3 a0 = x - ox;
                    m *= (1.79284291400159 - 0.85373472077480 * ( a0*a0 + h*h ));
                    vec3 g;
                    g.x  = a0.x  * x0.x  + h.x  * x0.y;
                    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                    return 130.0 * dot(m, g);
                }
                void main() {
                    vec3 pos = position;
                    float scrollWave = 1.0 - smoothstep(0.0, 0.5, abs(pos.y * 0.1 + u_scroll));
                    float noise = snoise(vec2(pos.x * 0.1 + u_time * 0.1, pos.y * 0.1 + u_time * 0.1));
                    float dist = distance(pos.xy, u_mouse);
                    float mouseWave = 1.0 - smoothstep(0.0, u_mouse_wave_radius, dist);
                    pos.z += (scrollWave * 2.0) + (noise * 0.2) + (mouseWave * u_mouse_wave_intensity);
                    v_wave = scrollWave;
                    v_mouse_wave = mouseWave;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 u_color_a, u_color_b, u_color_interaction;
                varying float v_wave, v_mouse_wave;
                void main() {
                    vec3 scrollColor = mix(u_color_a, u_color_b, v_wave);
                    vec3 finalColor = mix(scrollColor, u_color_interaction, v_mouse_wave);
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
            wireframe: true,
            transparent: true,
            opacity: 0.5
        });

        const circuit = new THREE.Mesh(geometry, material);
        circuit.rotation.x = -0.3;
        scene.add(circuit);

        const lerp = (a, b, t) => (1 - t) * a + t * b;
        let scrollY = window.scrollY;
        let currentScroll = window.scrollY;
        window.addEventListener('scroll', () => { scrollY = window.scrollY; });

        const mouse = new THREE.Vector2(0, 0);
        const targetMouse = new THREE.Vector2(0, 0);
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            currentScroll = lerp(currentScroll, scrollY, 0.05);
            const scrollableHeight = document.body.scrollHeight - window.innerHeight;
            const scrollProgress = scrollableHeight > 0 ? currentScroll / scrollableHeight : 0;
            targetMouse.lerp(mouse, settings.mouseFollowSpeed);
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
            const width = height * camera.aspect;
            const mouse3D_x = targetMouse.x * (width / 2);
            const mouse3D_y = targetMouse.y * (height / 2);
            material.uniforms.u_scroll.value = lerp(2.5, -2.5, scrollProgress);
            material.uniforms.u_time.value = elapsedTime;
            material.uniforms.u_mouse.value.set(mouse3D_x, mouse3D_y);
            camera.position.x = Math.sin(elapsedTime * 0.1) * 0.5;
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }
        animate();

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }
        window.addEventListener('resize', onWindowResize);

        // --- Sincronizador de Selección para Editor de Estilos ---
        let selectedElement = null;
        document.body.addEventListener('click', (event) => {
            // Eliminar el resaltado anterior
            if (selectedElement) {
                selectedElement.style.outline = '';
            }

            // Encontrar el componente clickeado más cercano
            const target = event.target.closest('[id]');

            if (target) {
                selectedElement = target;
                selectedElement.style.outline = '2px solid #67e8f9'; // Resaltado cian

                // Enviar el ID del elemento seleccionado al editor
                window.parent.postMessage({
                    type: 'element-selected',
                    payload: {
                        id: target.id
                    }
                }, '*');
            }
        });

        // --- Sincronizador de Edición In-place ---
        document.body.addEventListener('input', (event) => {
            const target = event.target;
            if (target.isContentEditable) {
                const id = target.id;
                if (id) {
                    window.parent.postMessage({
                        type: 'inline-edit',
                        payload: {
                            id: id,
                            newText: target.innerHTML
                        }
                    }, '*');
                }
            }
        });

        // --- Lógica del Overlay de Espaciado Interactivo ---
        const spacingOverlay = document.getElementById('spacing-overlay');
        let currentSection = null;

        document.body.addEventListener('mouseover', (event) => {
            const section = event.target.closest('section');
            if (section && section !== currentSection) {
                currentSection = section;
                const rect = section.getBoundingClientRect();

                spacingOverlay.style.display = 'block';
                spacingOverlay.style.top = `${rect.top + window.scrollY}px`;
                spacingOverlay.style.left = `${rect.left + window.scrollX}px`;
                spacingOverlay.style.width = `${rect.width}px`;
                spacingOverlay.style.height = `${rect.height}px`;
            }
        });

        document.getElementById('app-container').addEventListener('mouseleave', () => {
             if (!isDragging) {
                spacingOverlay.style.display = 'none';
                currentSection = null;
             }
        });

        // --- Lógica de Arrastre de los Manejadores ---
        let isDragging = false;
        let startY = 0, startX = 0;
        let handleDirection = null;
        let initialPadding = 0;
        const PIXELS_PER_UNIT = 4; // 1 unidad de Tailwind (ej. pt-4) equivale a 1rem = 16px. Usamos 4px/unidad para más granularidad.

        spacingOverlay.addEventListener('mousedown', (event) => {
            const handle = event.target.closest('.handle');
            if (handle && currentSection) {
                const sectionSchema = currentSchema.find(s => s.id === currentSection.id);
                if (!sectionSchema || !sectionSchema.spacing) return;

                isDragging = true;
                startY = event.clientY;
                startX = event.clientX;
                handleDirection = handle.dataset.direction;
                initialPadding = parseInt(sectionSchema.spacing[handleDirection], 10) || 0;

                document.body.style.cursor = 'grabbing';
                event.preventDefault();
            }
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging || !currentSection) return;

            const deltaY = event.clientY - startY;
            const deltaX = event.clientX - startX;
            let newPadding = initialPadding;

            switch(handleDirection) {
                case 'pt': newPadding = initialPadding + Math.round(deltaY / PIXELS_PER_UNIT); break;
                case 'pb': newPadding = initialPadding - Math.round(deltaY / PIXELS_PER_UNIT); break;
                case 'pl': newPadding = initialPadding + Math.round(deltaX / PIXELS_PER_UNIT); break;
                case 'pr': newPadding = initialPadding - Math.round(deltaX / PIXELS_PER_UNIT); break;
            }

            newPadding = Math.max(0, newPadding); // No permitir padding negativo

            // Actualización visual en tiempo real (directamente en el estilo para fluidez)
            currentSection.style.paddingTop = handleDirection === 'pt' ? `${newPadding * 4}px` : currentSection.style.paddingTop;
            currentSection.style.paddingBottom = handleDirection === 'pb' ? `${newPadding * 4}px` : currentSection.style.paddingBottom;
            currentSection.style.paddingLeft = handleDirection === 'pl' ? `${newPadding * 4}px` : currentSection.style.paddingLeft;
            currentSection.style.paddingRight = handleDirection === 'pr' ? `${newPadding * 4}px` : currentSection.style.paddingRight;
        });

        window.addEventListener('mouseup', (event) => {
            if (isDragging && currentSection) {
                isDragging = false;
                document.body.style.cursor = 'default';

                const deltaY = event.clientY - startY;
                const deltaX = event.clientX - startX;
                let newPadding = initialPadding;

                switch(handleDirection) {
                    case 'pt': newPadding = initialPadding + Math.round(deltaY / PIXELS_PER_UNIT); break;
                    case 'pb': newPadding = initialPadding - Math.round(deltaY / PIXELS_PER_UNIT); break;
                    case 'pl': newPadding = initialPadding + Math.round(deltaX / PIXELS_PER_UNIT); break;
                    case 'pr': newPadding = initialPadding - Math.round(deltaX / PIXELS_PER_UNIT); break;
                }
                newPadding = Math.max(0, newPadding);

                // Enviar el valor final al editor
                window.parent.postMessage({
                    type: 'visual-spacing-update',
                    payload: {
                        sectionId: currentSection.id,
                        direction: handleDirection,
                        newValue: newPadding
                    }
                }, '*');

                // Limpiar estilos en línea para que las clases de Tailwind tomen el control de nuevo
                currentSection.style.paddingTop = '';
                currentSection.style.paddingBottom = '';
                currentSection.style.paddingLeft = '';
                currentSection.style.paddingRight = '';
            }
        });

    </script>
</body>
</html>
